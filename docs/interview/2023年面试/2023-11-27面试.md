# 2023-11-23 Vivo外包推荐系统岗位面试

本次面试分为项目篇和技术篇。

## 项目篇

### 项目介绍，自己负责的模块，用到的技术



## 技术篇

### 1. synchronized用在方法和代码块的取别？

通过反编译javap命令

#### 修饰同步代码块

修饰代码块，则在编译器编译之后，会给synchronized关键字之前和之后加上`monitorenter`和`monitorexit`指令，获取锁和释放锁。

```java
void test(Foo f) {
	sychronized(f) {
		dosomething();
	}
}

// 字节码指令
Method void test(Foo)
0: aload_1              // 将对象f入栈
1: dup                  // 复制栈顶元素             
2: astore_2             
3: monitorenter        //申请获得对象的内置锁
4: aload_0
5: invokevirtual #5    // 调用dosomething方法
8: aload_2
9: monitorexit         //释放对象内置锁
10: goto          18   // 方法正常退出，跳转到18返回
13: astore_3		   // 从这部开始是异常路径，当方法出现异常的流程
14: aload_2				// 将异常对象入栈
15: monitorexit         //释放对象内置锁,退出同步
16: aload_3
17: athrow              // 将异常对象重新抛出给test()方法的调用者
18: return				// 方法正常返回

```

sychronized修饰方法

修饰方法和使用代码块的底层原理都是相同的，就是使用的位置有所区别。

方法级的同步是隐式的，对于sychronized修饰的方法来讲，在生成的class文件的方发表中会有标识`ACC_SYCHRONIZED`访问标识，声明该方法是否为一个同步方法，当线程访问到方法的时候，如果发现有该标识，则会先获取锁，在方法执行完成之后会释放锁。相当于在方法前和方法后隐式的增加了`monitorenter`和`monitorexit`指令。

#### 修饰同步方法

### 2. 同一个类中两个synchronized方法，在同一时刻能被两个线程同时访问吗？

不同实例之间可以被两个线程同时访问。同一个实例当中，应为获取的时是同一个实例对象的锁，所以同一实例对象当中多个synchronized方法在同一时刻只能被一个线程访问，不能同时访问。

### 3. Kafka的Producer，Topic，Partition，Consumer的区别和联系？

Producer（生产者）：产生消息的一方。

Consumer（消费者）：消费消息的一方

Topic（主题）：Producer将消息发送到特定的主题，Consumer通过订阅特定的主题来消费消息。

Partition（分区）：Partition属于Topic的一部分。一个Topic可以有多个Partition，同一Topic下的不同分区可以分布在不同Broker上，这表明一个Topic可以横跨多个Broker。

Broker（代理）：可以看作是一个独立的Kafka实例，多个Kafka Broker组成Kafka Cluster。

### 4. Kafka的消费者和消费者组的区别和联系？

消费者：通过订阅一个或多个Topic主题，消费消息的实体。

消费者组：消费者从属于消费者组。同一个消费者组内的消费者通过分区分配来接手不同分区的消息。

1. 对于统一消费者组，一条消息只能被其中一个消费者消费。
2. 一个消费者可以从多个分区中消费消息。但对于每一个消费者组每个分区在同一时刻只能被一个消费者消费。
3. 不同消费者群组之间互不影响。

#### 当Kafka的消费者大于Partition的数量会有什么问题？

##### 1. 相同消费者组内, 消费者数Consumer > partition

![image-20231127212613451](2023面试集锦.assets/image-20231127212613451.png)

如上图，向test1发送，1、2、3、4、5、6、7、8、9条消息

只有c1可以消费消息，c2则不能接收到消息。即同一Partition内的消息只能被同一消费者组中的一个Consumer消费。当消费者数量大于Partition的数量时，多余的消费者空闲。

也就是说如果只有一个Partition，你在同一个消费者组内启动多个消费者Consumer也是只有一个Consumer消费到消息。Partition的数量决定了这个Topic在同一个消费者组中可被均衡的程度。如partition=3则可在同一组中被最多3个consumer均衡消费。

#### 2. 相同消费者组内, 消费者数Consumer <= partition

![image-20231127213235884](2023面试集锦.assets/image-20231127213235884.png)



当消费者Consumer2个，Partition分区3个。此时，向test2中发送1、2、3、4、5、6、7、8、9条消息。

C1接收到1，3，4，6，7，9
C2接收到2，5，8
此时P1、P2对对应C1，即多个partition对应一个消费者，C1接收到消息量是C2的两倍
然后，在g3组中再启动一个消费者，使得消费者数量为3等于topic2中partition的数量

#### 3.不同消费者组内

![image-20231127213648473](2023面试集锦.assets/image-20231127213648473.png)

如上图，向test2发送消息1，2，3，4，5，6，7，8，9
消息被g3组的消费者均分，g4组的消费者在接收到了所有的消息。
g3组：
C1接收到了：2，5，8
C2接收到了：3，6，9
C3接收到了：1，4，7
g4组：
C1接收到了：1，2，3，4，5，6，7，8，9
启动多个组，则会使同一个消息被消费多次

### 5. Volatile关键字有什么作用？



### 6. CAS是什么？是乐观锁还是悲观锁？

CAS 是Compare And Swap 比较和交换的意思。就是一个内存中的值V，一个期望值E，一个要写入的新值N，只有当V的值等于E的值才会写入，否则不做操作。它是一种乐观锁的实现。

可能产生ABA问题。

可以使用version字段解决。或者使用带有Stamp的原子类。 

### 7. 创建SpringBean的方式？



### 8. AOP是什么



### 9. CMS和G1收集器的区别？

**使用范围：**

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用

G1收集器的使用范围是新生代和老年代，不需要结合其他收集器使用。

**SWT时间:**

CMS收集器是以最小停顿时间为目的的收集器。

G1收集器是可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

**垃圾碎片：**

CMS收集器是采用的“标记-清除”算法进行垃圾回收，会产生内存碎片。

G1收集器是采用的“标记-整理”算法，没有内存空间碎片。

**收集过程：**

CMS收集器：初始标记 -> 并发标记 -> 重新标记 ->并发清除

G1收集器：初始标记 -> 并发标记 -> 最终标记 -> 筛选回收

**CMS会产生浮动垃圾**

 CMS产生浮动垃圾过多时会退化为serial old，效率低，而G1没有浮动垃圾，因为在上图的第四阶段，CMS清除垃圾时是并发清除的，这个时候，垃圾回收线程和用户线程同时工作会产生浮动垃圾，也就意味着CMS垃圾回收器必须预留一部分内存空间用于存放浮动垃圾，而G1的筛选回收是多个垃圾回收线程并行gc的，没有浮动垃圾的回收

 在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。

